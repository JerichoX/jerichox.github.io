---
layout:     post
title:      我的面试记录
subtitle:   求知若饥,虚心若愚
date:       2019-10-17
author:     Jericho
header-img: img/article-pic/143522.jpg
catalog: false
categories: Technology
tags:
    - Java
---

##### 1. 讲一下redis的主从复制怎么做的？
简单来说就是“配从不配主”，在从节点中发送`slaveof 主节点地址`就可以复制主节点数据到从节点。

##### 2. ArrayList list = new ArrayList(20);中的list扩充几次？
扩充0次，因为直接指明了list的长度，所以就直接初始化大小为20的list，没有扩容。
如果没有指明长度，ArrayList()构造长度为10的空列表，扩容则扩容为原来长度的1.5倍。

##### 3. sql索引相关
索引的分类：单列索引（普通索引[无约束]、唯一索引[UNIQUE]、主键索引[PRIMARY]）、组合索引、全文索引、空间索引；

添加索引：
1. 可以直接在创建表的时候为字段添加索引，例如添加主键索引；

2. 在已经存在的表上创建索引：`ALTER TABLE 表名 ADD [UNIQUE|FULLTEXT|SPATIAL] [INDEX|KEY] [索引名] (索引字段名)[ASC|DESC]`

3. 使用CREATE INDEX创建索引：`CREATE [UNIQUE|FULLTEXT|SPATIAL] [INDEX|KEY] 索引名称 ON 表名(创建索引的字段名[length])[ASC|DESC]`

查看指定表中的索引：`SHOW INDEX FROM table_name`

EXPLAIN关键字，用来查看索引是否正在被使用，验证索引，如果为age字段设置了索引，执行`EXPLAIN SELECT * FROM table_name WHERE age = 99`，会返回用到的索引的信息；

删除索引：

1. `ALTER TABLE 表名 DROP INDEX 索引名`

2. `DROP INDEX 索引名 ON 表名`

学习自：[简书](https://www.jianshu.com/p/0d6c828d3c70)

##### 4. 为什么重写equals一定要重写hashcode？
当我们向哈希表(如HashSet、HashMap等)中添加对象object时，首先调用hashCode()方法计算object的哈希码，通过哈希码可以直接定位object在哈希表中的位置(一般是哈希码对哈希表大小取余)。如果该位置没有对象，可以直接将object插入该位置；如果该位置有对象(可能有多个，通过链表实现)，则调用equals()方法比较这些对象与object是否相等，如果相等，则不需要保存object；如果不相等，则将该对象加入到链表中。

这也就解释了为什么equals()相等，则hashCode()必须相等。如果两个对象equals()相等，则它们在哈希表(如HashSet、HashMap等)中只应该出现一次；如果hashCode()不相等，那么它们会被散列到哈希表的不同位置，哈希表中出现了不止一次。

##### 5. 介绍一下TCP/IP三次握手的原理
    ACK： 响应数据包
    SYN： 主动建立连接数据包

第一次握手
客户主动（active open）去connect服务器，并且发送SYN 假设序列号为J,服务器是被动打开(passive open)；

第二次握手
服务器在收到SYN后，它会发送一个SYN以及一个ACK（应答）给客户，ACK的序列号是 J+1表示是给SYN J的应答，新发送的SYN K 序列号是K；

第三次握手
客户在收到新SYN K, ACK J+1 后，也回应ACK K+1 以表示收到了，然后两边就可以开始数据发送数据了。

##### 6. 什么是死锁？死锁产生的条件是什么？如何避免死锁？
死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

四个必要条件：互斥条件、不可剥夺条件、请求和保持条件、循环等待条件。
<br/>互斥条件：资源是独占的且排他使用，进程互斥使用资源，即任意时刻一个资源只能给一个进程使用，其他进程若申请一个资源，而该资源被另一进程占有时，则申请者等待直到资源被占有者释放。
<br/>不可剥夺条件：进程所获得的资源在未使用完毕之前，不被其他进程强行剥夺，而只能由获得该资源的进程资源释放。
<br/>请求和保持条件：进程每次申请它所需要的一部分资源，在申请新的资源的同时，继续占用已分配到的资源。
<br/>循环等待条件：在发生死锁时必然存在一个进程等待队列，且形成一个进程等待环路，环路中每一个进程所占用的资源同时也是另一个进程所要申请，也就是前一个占有后一个进程所要申请的资源。

[避免死锁的方法](https://wiki.jikexueyuan.com/project/java-concurrent/deadlock-prevention.html)

##### 7. 写出一段代码模拟产生死锁的情况
思路:
定义两个资源o1，o2
对象deadLock1占有资源o1，需要资源o2
对象deadLock2占有资源o2，需要资源o1
死锁产生

代码：

    public class DeadLock implements Runnable {
        // flag=1，占有对象o1，等待对象o2
        // flag=0，占有对象o2，等待对象o1
        public int flag = 1;
    
        // 定义两个Object对象，模拟两个线程占有的资源
        public static Object o1 = new Object();
        public static Object o2 = new Object();
    
        public static void main(String[] args) {
        
            DeadLock deadLock1 = new DeadLock();
            DeadLock deadLock2 = new DeadLock();
    
            deadLock1.flag = 0;
            deadLock2.flag = 1;
    
            Thread thread1 = new Thread(deadLock1);
            Thread thread2 = new Thread(deadLock2);
    
            thread1.start();
            thread2.start();
    
        }
    
        public void run() {
    
            System.out.println("flag: " + flag);
    
            // deadLock2占用资源o1，准备获取资源o2
            if (flag == 1) {
                synchronized (o1) {
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    synchronized (o2) {
                        System.out.println("1");
                    }
                }
            }
    
            // deadLock1占用资源o2，准备获取资源o1
            else if (flag == 0) {
                synchronized (o2) {
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    synchronized (o1) {
                        System.out.println("0");
                    }
                }
            }
        }
    }

##### [8. Lock的用法](https://blog.csdn.net/weixin_40583386/article/details/86170355)

##### [9. linux常见的命令有哪些？](https://www.cnblogs.com/caozy/p/9261224.html#!comments)

##### 10. 将一个单链表的数据反转，时间复杂度为O(n)







